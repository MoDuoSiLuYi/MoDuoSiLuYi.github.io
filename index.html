

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR.js 冬至贺卡</title>
    <style>
        html, body { width: 100%; height: 100%; }
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; -webkit-user-select: none; user-select: none; }
        a-scene { position: fixed !important; inset: 0 !important; width: 100vw !important; height: 100vh !important; }
        video, canvas, .a-canvas { width: 100% !important; height: 100% !important; }
        video { object-fit: cover; }
        #info {
            position: absolute;
            top: calc(10px + env(safe-area-inset-top));
            left: 0;
            right: 0;
            width: 100%;
            padding: 0 16px;
            box-sizing: border-box;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 5px #ff0000, 0 0 10px #00ff00;
        }
        h1 { margin: 0; font-size: clamp(22px, 6vw, 40px); }
        p { margin: 6px 0 0; font-size: clamp(12px, 3.6vw, 18px); }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 18px;
            z-index: 101;
        }
        #tuner {
            position: fixed;
            left: 12px;
            right: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom));
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-family: Arial, sans-serif;
            z-index: 9999;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }
        #tunerRow { display: grid; grid-template-columns: 44px 1fr 52px; gap: 8px; align-items: center; margin-top: 6px; }
        #tuner input[type="range"] { width: 100%; }
        #tunerButtons { display: flex; gap: 8px; margin-top: 10px; }
        #tuner button {
            flex: 1;
            padding: 8px 10px;
            border: 0;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.12);
            color: #fff;
            font-size: 14px;
        }
        #tunerTitle { display: flex; justify-content: space-between; align-items: center; }
        #tunerState { opacity: 0.85; font-size: 12px; }
    </style>
    <script src="./vendor/aframe.min.js" onerror="window.__libLoadError='aframe'"></script>
    <script src="./vendor/aframe-ar.min.js" onerror="window.__libLoadError='arjs'"></script>
    <script src="./vendor/aframe-extras.min.js" onerror="window.__libLoadError='extras'"></script>
</head>
<body>
    <div id="info">
        <h1>冬至快乐</h1>
        <p>将相机对准 Hiro 标记或您的贺卡</p>
    </div>
    <div id="loading">正在加载 AR 场景...</div>
    <div id="tuner">
        <div id="tunerTitle">
            <div>角度调教</div>
            <div id="tunerState">未识别到标记</div>
        </div>
        <div id="tunerRow">
            <div>X</div>
            <input id="rx" type="range" min="-180" max="180" step="1" value="0">
            <div id="rxv">0</div>
        </div>
        <div id="tunerRow">
            <div>Y</div>
            <input id="ry" type="range" min="-180" max="180" step="1" value="0">
            <div id="ryv">0</div>
        </div>
        <div id="tunerRow">
            <div>Z</div>
            <input id="rz" type="range" min="-180" max="180" step="1" value="0">
            <div id="rzv">0</div>
        </div>
        <div id="tunerButtons">
            <button id="presetFront">正面</button>
            <button id="presetFlip">翻面</button>
            <button id="presetReset">重置</button>
        </div>
    </div>
    <div id="sceneRoot"></div>
    <script>
        var sceneRootEl = document.getElementById('sceneRoot');
        var loadingEl = document.getElementById('loading');
        if (!window.AFRAME || !window.THREE) {
            if (loadingEl) loadingEl.textContent = '依赖加载失败，请检查 ./vendor 下文件是否存在后刷新';
            throw new Error('A-Frame/Three not loaded: ' + String(window.__libLoadError || 'unknown'));
        }
        var modelEl = null;
        var rootEl = null;
        var markerEl = null;
        var tapAreaEl = null;
        var stateEl = document.getElementById('tunerState');
        var rxEl = document.getElementById('rx');
        var ryEl = document.getElementById('ry');
        var rzEl = document.getElementById('rz');
        var rxvEl = document.getElementById('rxv');
        var ryvEl = document.getElementById('ryv');
        var rzvEl = document.getElementById('rzv');
        var presetFrontEl = document.getElementById('presetFront');
        var presetFlipEl = document.getElementById('presetFlip');
        var presetResetEl = document.getElementById('presetReset');
        var baseRootRot = { x: 0, y: 0, z: 0 };
        var baseModelRot = { x: 0, y: 0, z: 0 };
        var isOpen = false;
        var animationDurationMs = 0;
        var markerVisible = false;
        var hasAutoPlayed = false;
        var clipName = 'Animation';

        function createEl(tag, attrs) {
            var el = document.createElement(tag);
            if (attrs) {
                Object.keys(attrs).forEach(function (k) {
                    if (attrs[k] === null || typeof attrs[k] === 'undefined') return;
                    el.setAttribute(k, attrs[k]);
                });
            }
            return el;
        }

        function mountScene() {
            if (!sceneRootEl) return;
            sceneRootEl.innerHTML = '';
            var modelUrl = './scene.gltf?v=' + String(Date.now());

            var sceneAttrs = {
                'vr-mode-ui': 'enabled: false',
                renderer: 'colorManagement: true; physicallyCorrectLights: false; antialias: true; precision: highp; logarithmicDepthBuffer: true',
                arjs: 'sourceType: webcam; trackingMethod: best; debugUIEnabled: false'
            };

            var sceneEl = createEl('a-scene', sceneAttrs);

            var lights = function (parent) {
                parent.appendChild(createEl('a-entity', { light: 'type: ambient; color: #ffffff; intensity: 1.0' }));
                parent.appendChild(createEl('a-entity', { light: 'type: directional; color: #ffffff; intensity: 1.5', position: '1 2 1' }));
            };

            markerEl = createEl('a-marker', { id: 'hiroMarker', preset: 'hiro', smooth: 'true', smoothCount: '20', smoothTolerance: '0.01', smoothThreshold: '2' });
            tapAreaEl = createEl('a-plane', { id: 'tapArea', class: 'clickable', rotation: '-90 0 0', position: '0 0 0', width: '1', height: '1', material: 'transparent: true; opacity: 0.001' });
            markerEl.appendChild(tapAreaEl);
            rootEl = createEl('a-entity', { id: 'cardRoot', rotation: '0 0 90' });
            modelEl = createEl('a-entity', {
                id: 'cardEntity',
                class: 'clickable',
                'gltf-model': modelUrl,
                'animation-mixer': 'clip: Animation; loop: once; clampWhenFinished: true; timeScale: 0',
                position: '0 0.05 0',
                rotation: '0 0 0',
                scale: '1 1 1'
            });
            rootEl.appendChild(modelEl);
            markerEl.appendChild(rootEl);
            lights(markerEl);
            sceneEl.appendChild(markerEl);
            sceneEl.appendChild(createEl('a-entity', { camera: 'near: 0.2; far: 12', cursor: 'rayOrigin: mouse; fuse: false', raycaster: 'objects: .clickable' }));

            sceneRootEl.appendChild(sceneEl);
            baseRootRot = rootEl ? rootEl.getAttribute('rotation') : { x: 0, y: 0, z: 0 };
            baseModelRot = modelEl ? modelEl.getAttribute('rotation') : { x: 0, y: 0, z: 0 };
        }

        function setTuner(x, y, z) {
            if (!rootEl) return;
            rxEl.value = String(x);
            ryEl.value = String(y);
            rzEl.value = String(z);
            rxvEl.textContent = String(x);
            ryvEl.textContent = String(y);
            rzvEl.textContent = String(z);
            rootEl.setAttribute('rotation', x + ' ' + y + ' ' + z);
        }

        function syncTunerFromRoot() {
            if (!rootEl) return;
            var r = rootEl.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
            setTuner(Math.round(r.x || 0), Math.round(r.y || 0), Math.round(r.z || 0));
        }

        function bindTuner() {
            if (!rxEl || !ryEl || !rzEl || !rootEl) return;
            function apply() {
                var x = Number(rxEl.value);
                var y = Number(ryEl.value);
                var z = Number(rzEl.value);
                setTuner(x, y, z);
            }
            rxEl.addEventListener('input', apply);
            ryEl.addEventListener('input', apply);
            rzEl.addEventListener('input', apply);
            if (presetFrontEl) presetFrontEl.addEventListener('click', function () { setTuner(0, 0, 90); });
            if (presetFlipEl) presetFlipEl.addEventListener('click', function () { setTuner(0, 180, 90); });
            if (presetResetEl) presetResetEl.addEventListener('click', function () {
                if (rootEl && baseRootRot) rootEl.setAttribute('rotation', (baseRootRot.x || 0) + ' ' + (baseRootRot.y || 0) + ' ' + (baseRootRot.z || 0));
                if (modelEl && baseModelRot) modelEl.setAttribute('rotation', (baseModelRot.x || 0) + ' ' + (baseModelRot.y || 0) + ' ' + (baseModelRot.z || 0));
                syncTunerFromRoot();
            });
            syncTunerFromRoot();
        }

        function isPowerOfTwo(n) {
            return n > 0 && (n & (n - 1)) === 0;
        }

        function nextPowerOfTwo(n) {
            return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));
        }

        function getRenderer() {
            var s = sceneRootEl ? sceneRootEl.querySelector('a-scene') : document.querySelector('a-scene');
            return s && s.renderer ? s.renderer : null;
        }

        function potifyTexture(tex) {
            if (!tex || !tex.image || !window.THREE) return null;
            var img = tex.image;
            if (!img.width || !img.height) return null;

            var potW = isPowerOfTwo(img.width) ? img.width : nextPowerOfTwo(img.width);
            var potH = isPowerOfTwo(img.height) ? img.height : nextPowerOfTwo(img.height);
            if (potW === img.width && potH === img.height) return null;

            var canvas = document.createElement('canvas');
            canvas.width = potW;
            canvas.height = potH;
            var ctx = canvas.getContext('2d');
            if (!ctx) return null;
            ctx.drawImage(img, 0, 0, potW, potH);

            var newTex = new THREE.CanvasTexture(canvas);
            newTex.flipY = tex.flipY;
            newTex.wrapS = THREE.ClampToEdgeWrapping;
            newTex.wrapT = THREE.ClampToEdgeWrapping;
            newTex.magFilter = THREE.LinearFilter;
            newTex.minFilter = THREE.LinearMipmapLinearFilter;
            newTex.generateMipmaps = true;
            if (typeof tex.encoding !== 'undefined') newTex.encoding = tex.encoding;
            if (typeof tex.colorSpace !== 'undefined') newTex.colorSpace = tex.colorSpace;
            newTex.needsUpdate = true;
            return newTex;
        }

        function patchTexture(tex) {
            if (!tex || !window.THREE) return tex;
            if (tex.__patched) return tex;

            var renderer = getRenderer();
            var maxAniso = renderer && renderer.capabilities && renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;

            var maybePotTex = potifyTexture(tex);
            var t = maybePotTex || tex;

            t.wrapS = THREE.ClampToEdgeWrapping;
            t.wrapT = THREE.ClampToEdgeWrapping;
            t.magFilter = THREE.LinearFilter;
            t.minFilter = THREE.LinearMipmapLinearFilter;
            t.generateMipmaps = true;
            t.anisotropy = Math.max(1, maxAniso || 1);
            t.needsUpdate = true;
            t.__patched = true;
            return t;
        }

        function isInnerPageNode(node) {
            var n = node && node.name ? String(node.name) : '';
            var p = node && node.parent && node.parent.name ? String(node.parent.name) : '';
            return /(Right_Card|Card_Left|Card\.001)/i.test(n) || /(Right_Card|Card_Left|Card\.001)/i.test(p);
        }

        function patchMaterial(mat, node) {
            if (!mat || !window.THREE) return;
            mat.polygonOffset = true;
            mat.polygonOffsetFactor = 2;
            mat.polygonOffsetUnits = 2;
            mat.depthTest = true;
            mat.depthWrite = true;
            if (mat.map) {
                var baseTex = patchTexture(mat.map);
                if (isInnerPageNode(node)) {
                    var tex = baseTex.clone();
                    tex.wrapS = THREE.RepeatWrapping;
                    tex.offset.x = 1;
                    tex.repeat.x = -1;
                    if (typeof baseTex.encoding !== 'undefined') tex.encoding = baseTex.encoding;
                    if (typeof baseTex.colorSpace !== 'undefined') tex.colorSpace = baseTex.colorSpace;
                    tex.needsUpdate = true;
                    mat.map = tex;
                } else {
                    mat.map = baseTex;
                }
            }
            mat.needsUpdate = true;
        }

        function patchObject(obj) {
            if (!obj) return;
            obj.traverse(function (node) {
                if (!node || !node.isMesh) return;
                node.frustumCulled = false;
                if (Array.isArray(node.material)) {
                    node.material.forEach(function (m) { patchMaterial(m, node); });
                } else {
                    patchMaterial(node.material, node);
                }
            });
        }

        function setMixer(opts) {
            if (!modelEl) return;
            var base = { clip: 'Animation', loop: 'once', clampWhenFinished: true };
            modelEl.setAttribute('animation-mixer', Object.assign(base, opts || {}));
        }

        function fitModelSize() {
            if (!modelEl || !window.THREE) return;
            if (modelEl.__modelFitted) return;
            var mesh = modelEl.getObject3D('mesh');
            if (!mesh) return;

            var box = new THREE.Box3().setFromObject(mesh);
            var center = box.getCenter(new THREE.Vector3());
            modelEl.object3D.position.sub(center);
            var size = box.getSize(new THREE.Vector3());
            var maxDim = Math.max(size.x, size.y, size.z);
            if (!isFinite(maxDim) || maxDim <= 0) return;

            var isMobile = (window.AFRAME && AFRAME.utils && AFRAME.utils.device && AFRAME.utils.device.isMobile && AFRAME.utils.device.isMobile());
            var targetMaxDim = isMobile ? 1.8 : 2.2;
            var scale = targetMaxDim / maxDim;
            (rootEl ? rootEl.object3D : modelEl.object3D).scale.set(scale, scale, scale);
            modelEl.__modelFitted = true;
        }

        function hideLoading() {
            if (loadingEl) loadingEl.style.display = 'none';
        }

        function bindModelEvents() {
            if (!modelEl) return;
            modelEl.addEventListener('model-loaded', function () {
                var mesh = modelEl.getObject3D('mesh');
                if (mesh && mesh.animations && mesh.animations.length) {
                    var clip = mesh.animations.find(function (c) { return c && c.name === 'Animation'; }) || mesh.animations[0];
                    if (clip && isFinite(clip.duration)) animationDurationMs = clip.duration * 1000;
                    if (clip && clip.name) clipName = clip.name;
                }
                patchObject(mesh);
                fitModelSize();
                hideLoading();
            });
            modelEl.addEventListener('model-error', function (e) {
                if (loadingEl) loadingEl.textContent = '模型加载失败，请确认通过 https 或 localhost 访问，并检查资源路径';
                console.error(e && e.detail ? e.detail : e);
            });
        }

        function bindMarkerEvents() {
            if (!markerEl) return;
            markerEl.addEventListener('markerFound', function () {
                hideLoading();
                if (stateEl) stateEl.textContent = '已识别到标记';
                markerVisible = true;
                if (!hasAutoPlayed) {
                    openCard();
                    hasAutoPlayed = true;
                }
            });
            markerEl.addEventListener('markerLost', function () {
                if (stateEl) stateEl.textContent = '未识别到标记';
                markerVisible = false;
            });
        }

        function trySeekAndPlay(timeScale, seekToEnd) {
            if (!modelEl || !window.THREE) return;
            var comp = modelEl.components ? modelEl.components['animation-mixer'] : null;
            if (!comp) return;
            var actions = [];
            if (Array.isArray(comp.activeActions)) actions = comp.activeActions;
            else if (Array.isArray(comp._actions)) actions = comp._actions;
            else if (comp.actions && typeof comp.actions === 'object') actions = Object.keys(comp.actions).map(function (k) { return comp.actions[k]; }).filter(Boolean);
            if (!actions.length) return;
            actions.forEach(function (action) {
                if (!action) return;
                var duration = action.getClip && action.getClip() && isFinite(action.getClip().duration) ? action.getClip().duration : 0;
                if (action.reset) action.reset();
                if (seekToEnd && duration) action.time = duration;
                if (action.setEffectiveTimeScale) action.setEffectiveTimeScale(timeScale);
                if (action.setEffectiveWeight) action.setEffectiveWeight(1);
                if (action.play) action.play();
            });
            if (comp.mixer && typeof comp.mixer.update === 'function') comp.mixer.update(0);
        }

        function restartMixer(timeScale, seekToEnd) {
            if (!modelEl) return;
            modelEl.removeAttribute('animation-mixer');
            requestAnimationFrame(function () {
                modelEl.setAttribute('animation-mixer', 'clip: ' + clipName + '; loop: once; clampWhenFinished: true; timeScale: ' + timeScale);
                requestAnimationFrame(function () {
                    trySeekAndPlay(timeScale, seekToEnd);
                });
            });
        }

        function openCard() {
            restartMixer(1, false);
            isOpen = true;
        }

        function closeCard() {
            restartMixer(-1, true);
            isOpen = false;
        }

        function toggleCard() {
            if (!modelEl) return;
            if (isOpen) closeCard();
            else openCard();
        }

        function bindClickTargets() {
            if (tapAreaEl) tapAreaEl.addEventListener('click', toggleCard);
            if (modelEl) modelEl.addEventListener('click', toggleCard);
        }
        document.addEventListener('pointerdown', function (e) {
            if (!markerVisible) return;
            if (e && e.target && e.target.closest && e.target.closest('#tuner')) return;
            toggleCard();
        });
        mountScene();
        bindClickTargets();
        bindModelEvents();
        bindMarkerEvents();
        bindTuner();
    </script>
</body>
</html>
